\chapter{OclTypeGenerator}
\label{appendix:generator}

OclTypeGenerator is a tool designed to generate the templates in Appendix \ref{appendix:vectemplate}. This is necessary because although there are certain differences between these templates, there are far more similarities. 

In fact, there are only 2 factors that need to be considered when generating a template:
\begin{itemize}
\item whether the base type for which the template is generated is an integer type (char, uchar, short, ushort, int, uint, long, ulong) or a floating point type (float, double)
\item whether it is a base template or a template specialization\footnote{For the generic C++ IR version, there are only 2 necessary specializations: the dummy specialization, with 0 components, and the scalar specialization, with 1 component. For the version that uses \vectype{} as internal storage, there is one specialization for each possible number of components, because the internal storage is different (and so are the packing and unpacking sequences).}
\end{itemize}

OclTypeGenerator checks these factors only when necessary. For instance, before overriding the modulo operator, it checks whether the current base type is an integer type - if it is not, it returns without generating the overriding function. Template specializations, however, are more different from one another: for instance, while the base template has a plethora of operator overrides, the dummy specialization overrides only the comma operator, whereas the scalar specialization only the comma and conversion operators. Neither specialization provides the read and write methods, and the dummy specialization also has no internal storage and no constructors. Therefore, it is useful to have a structure that stores what needs to be generated for each specialization. Such a structure can be seen in Listing \ref{lst:settings}.

\begin{lstlisting}[
	label=lst:settings, 
	caption=Structure used for configuring the generation of template specializations]
// Instances of this structure are obtained from a factory method that takes the 
// current specialization as an argument. The generator will check these values 
// before generating the corresponding code.
struct Settings {
		bool generateInternalVector;
		bool generateConstructors;
		bool generateBaseConstructor;
		bool generateConstructorOverloads;
		bool generateDestructor;
		bool generateReadMethods;
		bool generateWriteMethods;
		bool generateToStringMethod;
		bool generateIndexOperator;
		bool generateCommaOperator;
		bool generateConversionOperator;
		bool generateBinaryArithmeticOperators;
		bool generateUnaryArithmeticOperators;
		bool generateIncrementOperators;
		bool generateRelationalOperators;
		bool generateEqualityOperators;
		bool generateBitwiseOperators;
};
\end{lstlisting}

By automating the generation of the templates, it was relatively easy to replace the internal storage from the C-style array to \vectype{}. Ideally, this tool would also generate a library with functions to replace specific OpenCL syntax with the C++ IR (to be used by OclCompiler), so that when the representation changes the library is automatically updated\footnote{This functionality is not implemented in OclTypeGenerator.}.